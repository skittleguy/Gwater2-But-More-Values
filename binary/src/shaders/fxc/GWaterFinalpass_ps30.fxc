// DYNAMIC: "OPAQUE" "0..1"
// DYNAMIC: "NUM_LIGHTS"				"0..4"
// STATIC: "FLASHLIGHT"					"0..1"
// STATIC: "FLASHLIGHTDEPTHFILTERMODE"	"0..2"

// DYNAMIC: "FLASHLIGHTSHADOWS"			"0..1" 

#include "common_flashlight_fxc.h"
#include "shader_constant_register_map.h" 

float2 SCR_S		: register(c0);
float RADIUS		: register(c1);
float IOR 			: register(c2);
float REFLECTANCE 	: register(c3);
float4 COLOR2		: register(c12); 	

PixelShaderLightInfo cLightInfo[3]			: register( PSREG_LIGHT_INFO_ARRAY ); // c20 - c25, 2 registers each - 6 registers total (4th light spread across w's)
const float4 g_ShadowTweaks					: register( c26 ); // PSREG_ENVMAP_TINT__SHADOW_TWEAKS is supposed to be c2, we're using that already, so use c26 instead
const float4 g_FlashlightAttenuationFactors	: register( PSREG_FLASHLIGHT_ATTENUATION );			// c13, On non-flashlight pass
const float4 g_FlashlightPos_RimBoost		: register( PSREG_FLASHLIGHT_POSITION_RIM_BOOST ); // c14
const float4x4 g_FlashlightWorldToTexture	: register( PSREG_FLASHLIGHT_TO_WORLD_TEXTURE ); // c15
//const float3 cAmbientCube[6]				: register( PSREG_AMBIENT_CUBE ); // c4 - c9
//const float4 g_DiffuseModulation			: register( c11 ); // PSREG_DIFFUSE_MODULATION is supposed to be c2, but we're using that already, so use c11 instead

sampler NORMALS 	: register(s0);
sampler FRAMEBUFFER : register(s1);
sampler CUBEMAP		: register(s2);
sampler DEPTH		: register(s3);
sampler ShadowDepthSampler		: register( s4 );	// Flashlight shadow depth map sampler
sampler NormalizeRandRotSampler	: register( s5 );	// Normalization / RandomRotation samplers
sampler FlashlightSampler		: register( s6 );	// Flashlight cookie

struct PS_INPUT {
	float2 P 			: VPOS;
	float2 coord		: TEXCOORD0;
	float3 view_dir		: TEXCOORD1;
	float3 pos			: TEXCOORD2;
	float4x4 proj		: TEXCOORD3; 
	float4 lightAtten	: TEXCOORD8; // Scalar light attenuation factors for FOUR lights
};

#define OFFSET float2(0.5, 0.5)
#define SUN_DIR float3(-0.377821, 0.520026, 0.766044)	// TODO: get from map OR get lighting data

#define SpecularExponent 200
#define g_FlashlightPos					g_FlashlightPos_RimBoost.xyz

bool is_zero(float3 i) {
	return i.x == 0 && i.y == 0 && i.z == 0;
}

// Assumes that incoming IOR is 1
/*
float fresnel_approx(const float3 incident, const float3 normal) {
	float fresnel = saturate(dot(normal, incident));
	return pow(1.0 - fresnel, 5);
}*/

float fresnel_approx(float n1, float n2, float3 normal, float3 incident, float ref) {
        float r0 = (n1 - n2) / (n1 + n2);
        r0 *= r0;
        float cosX = -dot(normal, incident);
        /*if (n1 > n2){
            float n = n1/n2;
            float sinT2 = n*n*(1.0-cosX*cosX);
            if (sinT2 > 1.0)
                return 1.0;
            cosX = sqrt(1.0-sinT2);
        }*/
        float x = 1.0-cosX;
        float ret = r0+(1.0-r0)*x*x*x*x*x;
        ret = (ref + (1.0-ref) * ret);
        return min(ret, 1);
}

float4 final_output(float3 final) {
	return FinalOutput(float4(final, 1), 0, 0, TONEMAP_SCALE_LINEAR);
}

float4 main(const PS_INPUT i) : COLOR {
	// kill pixels outside of sphere
	float2 offset = (i.coord - 0.5) * 2.0;
	float radius2 = dot(offset, offset);
	if (radius2 > 1) discard;

	float3 diffuseLighting = float3(0.0f, 0.0f, 0.0f);
	//float3 ambientLighting = float3(0.0f, 0.0f, 0.0f);
    float3 specularLighting = float3(0.0f, 0.0f, 0.0f);

	float3 smoothed_normal = tex2D(NORMALS, i.P * SCR_S).xyz;
	
	// Weight the normals forward, as the only visible part is facing the player
	smoothed_normal = normalize(smoothed_normal + i.view_dir * REFLECTANCE * clamp(-dot(i.view_dir, smoothed_normal), REFLECTANCE, 1));

	float2 projPos = i.P * SCR_S;

	// Flashlight lighting (eg. a lamp is casting shadow)
	#if FLASHLIGHT
		float3 diffuseLightingFL = 0;
		float3 specularLightingFL = 0;
		float4 flashlightSpacePosition = mul(float4(i.pos, 1.0f), g_FlashlightWorldToTexture);
		if (flashlightSpacePosition.z > 0) {
			DoSpecularFlashlight(g_FlashlightPos, i.pos, flashlightSpacePosition, smoothed_normal,
				g_FlashlightAttenuationFactors.xyz, g_FlashlightAttenuationFactors.w,
				FlashlightSampler, ShadowDepthSampler, NormalizeRandRotSampler, FLASHLIGHTDEPTHFILTERMODE, FLASHLIGHTSHADOWS, true, projPos,
				SpecularExponent, -i.view_dir, false, FRAMEBUFFER, 0, g_ShadowTweaks,

				// These two values are output
				diffuseLightingFL, specularLightingFL);
		}

		#if OPAQUE // Opaque
				float3 absorption1 = COLOR2.xyz;// * (1.0 - fresnel); 

				float3 final_color1 = (COLOR2.xyz * diffuseLightingFL) + (specularLightingFL);
	
		#else // Translucent
				float3 final_color1 = specularLightingFL;
		#endif

		return FinalOutput(float4(final_color1, 1), 0, 0, TONEMAP_SCALE_LINEAR); // For HDR
	#else
		//float4 lightAtten = float4(1,1,1,1);
		// Local lights
		float3 rimLightingLL;
		float3 specularLightingLL;
		PixelShaderDoSpecularLighting(i.pos, smoothed_normal,
					SpecularExponent, -i.view_dir, i.lightAtten,
					NUM_LIGHTS, cLightInfo, false, 0, false, FRAMEBUFFER, 0, false, 1,

					// Outputs
					specularLightingLL, rimLightingLL);

		specularLighting += specularLightingLL;
	#endif
	
	specularLighting = pow(specularLighting, 1.0f/2.2f);

	// Secondary lighting calculations
#if OPAQUE // Opaque
	//float phong = min(pow(max(0, dot(reflected, SUN_DIR)), 100), 1);
	float3 diffuse = COLOR2.xyz * (dot(smoothed_normal, SUN_DIR) * 0.4 + 0.6);// * (1.0 - fresnel);

	return final_output(diffuse + specularLighting);
#else // Translucent
	float fresnel = fresnel_approx(1.0, IOR, i.view_dir, smoothed_normal, 0.0);
	float3 reflected = reflect(i.view_dir, smoothed_normal);
	float3 specular = (ENV_MAP_SCALE * texCUBE(CUBEMAP, reflected)).xyz * fresnel + specularLighting;

	// Calculate refraction vector in 3d space and project it to screen
	float3 uv_offset = smoothed_normal * -RADIUS;
	float4 uv = mul(float4(i.pos + uv_offset, 1), i.proj); uv.xy /= uv.w; 
	
	float2 refract_pos = float2(uv.x / 2.0 + 0.5, 0.5 - uv.y / 2.0);
	float3 refracted = tex2D(FRAMEBUFFER, refract_pos).xyz * (1.0 - fresnel);

	refracted = refracted / LINEAR_LIGHT_SCALE;

	float absorption_distance = tex2D(DEPTH, i.P * SCR_S).x * 100 * COLOR2.w;
	float3 absorption = exp((COLOR2.xyz - float3(1, 1, 1)) * absorption_distance);	// Beers law

	return final_output(absorption * refracted + specularLighting + specular);
#endif
};