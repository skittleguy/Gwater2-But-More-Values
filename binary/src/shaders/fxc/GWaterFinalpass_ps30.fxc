#include "common_ps_fxc.h"

float2 SCR_S		: register(c0);
float RADIUS		: register(c1);
float IOR 			: register(c2);
float REFLECTANCE 	: register(c3);

sampler NORMALS 	: register(s0);
sampler SCREEN 		: register(s1);
samplerCUBE CUBEMAP	: register(s2);
sampler DEPTH		: register(s3);

struct PS_INPUT {
	float2 P 		: VPOS;
	float2 coord	: TEXCOORD0;
	float4 eyepos	: TEXCOORD1;
	float3 pos		: TEXCOORD2;
	float4x4 proj	: TEXCOORD3;
	float4 color	: COLOR0;
};

bool is_zero(float3 i) {
	return i.x == 0 && i.y == 0 && i.z == 0;
};

// Assumes that incoming IOR is 1
float fresnelSchlicks(float3 incident, float3 normal, float ior) {
    float r0 = (1.0 - ior) / (1.0 + ior); 
	r0 *= r0;
	float cosX = abs(dot(incident, normal));
    float x = 1.0 - cosX;
    float ret = r0 + (1.0 - r0) * x * x * x * x * x;

	ret = (REFLECTANCE + (1.0 - REFLECTANCE) * ret);
    return min(ret, 1);
}
/*
float4 main(const PS_INPUT i) : COLOR {
	float2 offset = (i.coord - 0.5) * 2.0;

	// kill pixels outside of sphere
	float radius2 = dot(offset, offset);
	if (radius2 > 1) discard;

	// Calculate normal from texture coords
	float bulge = sqrt(1 - radius2);

	// Get smoothed normals if available. Use projected normal otherwise
	float3 smoothed_normal = tex2D(NORMALS, i.P / SCR_S).xyz;

	// Lighting calculations
	float3 sun_dir = float3(-0.377821, 0.520026, 0.766044);	// TODO: get from map OR get lighting data
	float3 view_dir = normalize(i.pos - i.eyepos.xyz);
	float3 reflected = reflect(view_dir, smoothed_normal);
	float phong = min(pow(max(0, dot(reflected, sun_dir)), 100), 1);
	float fresnel = fresnelSchlicks(view_dir, smoothed_normal, IOR);
	float3 specular = texCUBE(CUBEMAP, reflected).xyz * fresnel;
	
	bool is_translucent = i.color.w < 0.9999;	// rounding errors
	float diffuse = is_translucent ? 1.0 : dot(smoothed_normal, sun_dir) * 0.45 + 0.55;
	float absorption_distance = (tex2D(DEPTH, i.P / SCR_S).x * 100 + pow(dot(smoothed_normal, view_dir), 2) * 10) * i.color.w;
	//pow(dot(smoothed_normal, view_dir), 2)
	float3 absorption = is_translucent ? exp((i.color.xyz - float3(1, 1, 1)) * absorption_distance) : i.color.xyz;

	// Calculate refraction vector in 3d space and project it to screen
	float3 uv_offset = i.eyepos.w > RADIUS * 4.0 ? smoothed_normal * -RADIUS * 2.0 * IOR : float3(0, 0, 0);
	float4 uv = mul(float4(i.pos + uv_offset, 1), i.proj); uv.xy /= uv.w;
	float3 refracted = is_translucent ? tex2D(SCREEN, float2(uv.x / 2.0 + 0.5, 0.5 - uv.y / 2.0)).xyz : float3(1, 1, 1);
	refracted *= (1.0 - fresnel);

	// Calculate final color & return
	float3 final_color = absorption * refracted * diffuse + float3(phong, phong, phong) + specular;
	//return float4(final_color, 1);
	return FinalOutput(float4(final_color, 1), 0, 0, TONEMAP_SCALE_LINEAR, false, 0);	// For HDR
};*/

// calculates direction when given a pixel position on the screen
float3 calculate_dir(float2 uv, float4x4 proj) {
	return normalize(mul(float4(uv * float2(2.0, -2.0) + float2(-1.0, 1.0), 1, 1), proj).xyz);
}

float3 project_pos(float3 eyepos, float3 dir, float depth) {
	return eyepos + dir * depth;
}

float2 split_depth(float depth) {
	return float2(floor(depth), depth % 1);
}

float join_depth(float2 depth) {
	return depth.x + depth.y;
}

float4 main(const PS_INPUT i) : COLOR {
	float2 offset = (i.coord - 0.5) * 2.0;

	// kill pixels outside of sphere
	float radius2 = dot(offset, offset);
	if (radius2 > 1) discard;

	// Calculate normal from texture coords
	//float bulge = sqrt(1 - radius2);
	//float depth = i.eyepos.w - bulge * RADIUS;
	// Depth calculations
	//float3 view_dir = normalize(i.pos - i.eyepos.xyz);
	//float3 view_dir = mul(float4(i.P / SCR_S * float2(2.0, -2.0) + float2(-1.0, 1.0), 1, 1), i.proj).xyz;	// what the FUCK???
	//return float4(view_dir, 1);

	// extracted normal from depth
	
	/*float2 uv00 = i.P / SCR_S;
	float2 uv01 = (i.P + float2(0, 1)) / SCR_S;
	float2 uv10 = (i.P + float2(1, 0)) / SCR_S;

	float depth00 = join_depth(tex2D(NORMALS, uv00).xy);
	float depth01 = join_depth(tex2D(NORMALS, uv01).xy);
	float depth10 = join_depth(tex2D(NORMALS, uv10).xy);

	// nvidia hack, reverse normals direction if invalid
	if (abs(depth00 - depth01) > RADIUS) {
		//uv01 = (i.P - float2(0, 1)) / SCR_S;
		//depth01 = join_depth(tex2D(NORMALS, uv01).xy);
		//return float4(1, 0, 1, 1);
		depth01 = depth00 + 0.5;
	}
	if (abs(depth00 - depth10) > RADIUS) {
		//uv10 = (i.P - float2(1, 0)) / SCR_S;
		//depth10 = join_depth(tex2D(NORMALS, uv10).xy);
		//return float4(1, 0, 1, 1);
		depth10 = depth00 + 0.5;
	}

	float3 view_dir = calculate_dir(uv00, i.proj);
	float3 bulge_pos00 = project_pos(i.eyepos.xyz, view_dir, depth00);
	float3 bulge_pos01 = project_pos(i.eyepos.xyz, calculate_dir(uv01, i.proj), depth01);
	float3 bulge_pos10 = project_pos(i.eyepos.xyz, calculate_dir(uv10, i.proj), depth10);

	float3 smoothed_normal = normalize(cross(bulge_pos00 - bulge_pos01, bulge_pos00 - bulge_pos10));*/

	// extracted normal from depth
	float3 view_dir = normalize(i.pos - i.eyepos.xyz);
	float3 bulge_pos = project_pos(i.eyepos.xyz, view_dir, join_depth(tex2D(NORMALS, i.P / SCR_S).xy));
	float3 dx = -ddx(bulge_pos);	// right is reversed
	float3 dy = ddy(bulge_pos);
	float3 smoothed_normal;
	if (dot(dx, dx) > RADIUS * RADIUS || dot(dy, dy) > RADIUS * RADIUS) { // High frequency data, roll back to extracted normals from texcoord
	//if (true) {
		// this normals estimation is inefficient and has HORRIBLE artifacts. but this is edge detection so nobody will notice
		float bulge = sqrt(1 - radius2);
		float3 right = normalize(cross(-view_dir, float3(0, 0, 1)));
		float3 up = cross(right, view_dir);
		smoothed_normal = normalize(offset.y * up - offset.x * right - bulge * view_dir);
		//return float4(world_normal, 1);
	} else {
		smoothed_normal = normalize(cross(dx, dy));
	}
	
	// Lighting calculations
	float3 sun_dir = float3(-0.377821, 0.520026, 0.766044);	// TODO: get from map OR get lighting data
	float3 reflected = reflect(view_dir, smoothed_normal);
	float phong = min(pow(max(0, dot(reflected, sun_dir)), 100), 1);
	float fresnel = fresnelSchlicks(view_dir, smoothed_normal, IOR);
	float3 specular = texCUBE(CUBEMAP, reflected).xyz * fresnel;
	
	bool is_translucent = i.color.w < 0.9999;	// rounding errors
	float diffuse = is_translucent ? 1.0 : dot(smoothed_normal, sun_dir) * 0.45 + 0.55;
	float absorption_distance = (tex2D(DEPTH, i.P / SCR_S).x * 100 + pow(dot(smoothed_normal, view_dir), 2) * 10) * i.color.w;
	//pow(dot(smoothed_normal, view_dir), 2)
	float3 absorption = is_translucent ? exp((i.color.xyz - float3(1, 1, 1)) * absorption_distance) : i.color.xyz;

	// Calculate refraction vector in 3d space and project it to screen
	float3 uv_offset = i.eyepos.w > RADIUS * 4.0 ? smoothed_normal * -RADIUS * IOR : float3(0, 0, 0);
	float4 uv = mul(float4(i.pos + uv_offset, 1), i.proj); uv.xy /= uv.w;
	float3 refracted = is_translucent ? tex2D(SCREEN, float2(uv.x / 2.0 + 0.5, 0.5 - uv.y / 2.0)).xyz : float3(1, 1, 1);
	//float3 refracted = is_translucent ? tex2D(SCREEN, i.P / SCR_S).xyz : float3(1, 1, 1);
	refracted *= (1.0 - fresnel);

	// Calculate final color & return
	float3 final_color = absorption * refracted * diffuse + float3(phong, phong, phong) + specular;
	//return float4(final_color, 1);
	return FinalOutput(float4(final_color, 1), 0, 0, TONEMAP_SCALE_LINEAR, false, 0);	// For HDR
	
	//return float4(smoothed_normal, 1);
};