float RADIUS				: register(c0);

struct PS_INPUT {
	float2 P 		: VPOS;
	float2 coord	: TEXCOORD0;
	float3 pos  	: TEXCOORD1;
	float4x4 proj	: TEXCOORD2;
	float3 eye_pos	: NORMAL0;
	//float3x3 normal	: NORMAL0;
};

struct PS_OUTPUT {
	float4 rt0		: COLOR0;
	float4 rt1      : COLOR1;
	//float depth	: DEPTH0;
};
/*
PS_OUTPUT main(const PS_INPUT i) {
	float2 offset = (i.coord - 0.5) * 2.0;

	// kill pixels outside of sphere
	float radius2 = dot(offset, offset);
	if (radius2 > 1) discard;

	// Calculate normal from texture coords
	float bulge = sqrt(1 - radius2);
	float3 world_normal = mul(float3(offset.x, bulge, offset.y), i.normal);

	// Depth information for normals smoothing
	float2 uvdx = ddx(i.coord);
	float2 uvdy = ddy(i.coord);
	float uvdmax = 1.0 / sqrt(max(dot(uvdx, uvdx), dot(uvdy, uvdy)));

	// Depth calculations
	//float4 bulge_pos = mul(float4(i.pos.xyz + i.normal[1] * bulge * RADIUS, 1), i.proj);

	// Output colors to rendertargets
	PS_OUTPUT o = (PS_OUTPUT)0;
	o.rt0 = float4(world_normal, 1);
	o.rt1 = float4(uvdmax, i.pos.w - bulge * RADIUS, 0, 1);
	//o.depth = max(bulge_pos.z / bulge_pos.w, 0.03);	// 0.03 = default znear plane

	return o;
};*/


float3 project_pos(float3 eyepos, float3 dir, float depth) {
	return eyepos + dir * depth;
}

float2 split_depth(float depth) {
	int level = pow(2, floor(depth / 512));	// we are splitting a 32 bit float into two 16 bit floats. 16 bit floats have a 10 bit mantessa. 2^(10-1) = 512
	return float2(floor(depth / level) * level, depth % level);
}

float join_depth(float2 depth) {
	return depth.x + depth.y;
}

float4 main(const PS_INPUT i) : COLOR {
	float2 offset = (i.coord - 0.5) * 2.0;

	// kill pixels outside of sphere
	float radius2 = dot(offset, offset);
	if (radius2 > 1) discard;

	// Calculate depth from texture coords
	float bulge = sqrt(1 - radius2);
	float depth = distance(i.pos, i.eye_pos) + radius2 * RADIUS;//i.pos.w - bulge * RADIUS;

	// Depth information for normals smoothing
	float2 uvdx = ddx(i.coord);
	float2 uvdy = ddy(i.coord);
	float uvdmax = 1.0 / sqrt(max(dot(uvdx, uvdx), dot(uvdy, uvdy)));

	// Output colors to rendertargets
	return float4(split_depth(depth), uvdmax, 1);
};